## Introduction

What's brought you to this point in your career?

(Assume you are applying to Netflix)

## Hoisting

What is hoisting in JavaScript?  Give an example of how it might be used.

## `is_bst?`

Given a binary tree, write a function to check whether itâ€™s a binary
search tree or not.

```ruby
# O(n): must check every node (stops at first detected violation).
def is_bst?(node, min = nil, max = nil)
  return true if node.nil?

  # does this node violate constraints?
  if (min && (min > node.value)) || (max && (max < node.value))
    return false
  end

  # this node follows constraints; do its children, too?
  is_bst?(node.left, min, node.value) && is_bst?(node.right, node.value, max)
end
```

Time complexity: O(n)

## `findCommonAncestor`

Find the lowest common ancestor of two nodes in a binary search
tree. Write the function in JS. Assume I give you both the root and
the two nodes.

```js
// O(log(n))
function findCommonAncestor(root, nodeA, nodeB) {
  var currentNode = root;
  while true {
    if (currentNode == nodeA || currentNode == nodeB) {
      // one is the descendent of the other.
      return currentNode;
    }

    // is one of the nodes on the left, and the other on the right?
    var bothOnRight = ((currentNode.value < nodeA.value) &&
      (currentNode.value < nodeB.value));
    var bothOnLeft = ((currentNode.value > nodeA.value) &&
      (currentNode.value > nodeB.value));
    var onSameSide = bothOnRight || bothOnLeft;

    if (!onSameSide) {
      // the two nodes are on different sides.
      return currentNode;
    }

    currentNode = bothOnRight ? currentNode.right : currentNode.left;
  }
}
```


## Hash Dictionary

Suppose a hash representing a directory. All keys are strings with
names for either folders or files. Keys that are folders point to
nested hashes. Keys that are files point to "true". Write a function
that takes such a hash and returns an array of strings with the path to
each file in the hash.

**Example:**

```ruby
files = {
  'a' => {
    'b' => {
      'c' => {
        'd' => {
          'e' => true
        },

        'f' => true
      }
    }
  }
}

file_list(files) # => ['a/b/c/d/e', 'a/b/c/f']
```


```ruby
def file_list(hash)
  files = []

  hash.each do |item, nested_item|
    if nested_item.is_a?(Hash)
      folder = item
      nested_files = file_list(nested_item)
      nested_files.each { |file| files << "#{folder}/#{file}" }
    else
      files << item
    end
  end

  files
end
```

## `permutations`

Write a method that takes an array and returns all its
permutations. Time/memory complexity should be proportional to the
number of permutations; what is this?

```ruby
# O(n!)
def permutations(arr)
  return [[]] if arr.empty?

  perms = []
  arr.length.times do |i|
    # Choose an element to be first
    el = arr[i]
    rest = arr.take(i) + arr.drop(i + 1)

    # Find permutations of the rest, and tack the first `el` at front.
    new_perms = permutations(rest).map { |perm| perm.unshift(el) }
    perms.concat(new_perms)
  end

  perms
end
```