# 10`x` Engineer

---

### Let's go through some typical Definitions of `x`, shall we?

---

### If 1x is the output/quality/etc. of one average developer, then 10x is ten times that.

---

![not-good-enough](https://pics.onsizzle.com/maybe-iam-just-not-good-enough-5748077.png)

---

You do **NOT** have to be good at everything to be a 10x engineer. Having a
definition like that is just depressing and not realistic.

---

##### A 10x engineer is not necessarily 10 times more productive — they are just “next level” better engineers who in specific contexts are 1.5x and sometimes 100x better, depending on the difficulty of the task and leverage of the outcome.

---

![better-or-worse](http://s2.quickmeme.com/img/69/69244868047457a8495ef5dcde47c1e9a16a1b20554f3542e3de14b189151aba.jpg)

---

Okay, we're getting there. But this definition doesn't help. There's no path
toward it. No path being it. No path finding it.

---

![third-time](http://s2.quickmeme.com/img/c4/c4272af072b7c4f181478965c1db581d5f994f446349e9e93e521447273847ed.jpg)

---

##### Let x equal the sum of all gains realized by the actions of the developer, across all affected colleagues.

---

### Attributes

+ Strives for a deeper understanding
+ Proficiency in Efficiency
+ Positive influence to surrounding collaborators

---

### Deeper Understanding

+ Basically, do or learn one thing at a time *__really__* well
  + The amount of time you will spend going back to re-learn or re-do things
  will be massive over a longer period of time
  + 3 minutes / problem x 20 problems / day x 9 weeks = 45 hours
+ Understand patterns and their differences (pros and cons)
  + factory method vs explaining it (2 vs 20 words)
  + OOP vs Functional Programming

---

### Side Note: The 80-20 Rule

+ 80 percent of your code will be written in 20 percent of the time
+ 20 percent of your code will be written in 80 percent of the time
+ Why? Bugs.

Note: understanding how your code works and becoming familiar with the
debugging process overall will help you drastically reduce the amount of
time spent debugging / coding overall

---

### Proficiency in Efficiency

+ Learn your way around
  + terminal: bash
  + Atom: [shortcuts](https://github.com/nwinkler/atom-keyboard-shortcuts)
  + Frameworks: CLI or build your own!
    + *boilerplate* vs **business logic**
+ Automate
  + Test. Please, just test
  + Bots

---

### Tools and Resources

+ Know what tools and resources are available to you
  + learn your way around documentation and communities (not just Stack Overflow)
  + if you think you need it, someone probably made it
    + you won't need to handroll it most of the time
+ Linus Torvalds - developed the Linux kernel

---

### The Social Aspect

It's not just about what you can technically contribute - you can be a 10x
engineer by impacting those around you socially (and usually technically)

---

### Not all about the technicals

+ it's not enough to be a code-generating machine
  + help those around you - building trust and a collective knowledge base
  + secure, stress-free, supportive environment
  + __*communicate*__

---

### But back to the technicals

+ elegant code
  + not `Code Golf`
  + easily understood, yet impressive
+ regularly make detailed commits (gives people a good understanding
  of where your mind's at)
+ documentation (not as stressed in Ruby)

---

### Thought Experiment

+ if it's complicated enough that many people ask questions about it,
is your code really that efficient?

---
