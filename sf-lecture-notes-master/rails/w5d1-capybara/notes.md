# W5D1 Reading Recap

### Setting up RSpec with Rails
+ add `rspec-rails` to `group :development, :test do..`
+ make sure you have entries for a test db
+ each time you migrate `rake db:test:prepare`
+ `rails g rspec:install`
+ add the following to the `.rspec` generated by install command
```
--color
--require spec_helper
--format documentation
```
+ add the following to `config/application.rb`
```ruby
config.generators do |g|
  g.test_framework :rspec,
    :fixtures => false,
    :view_specs => false,
    :helper_specs => false,
    :routing_specs => false,
    :controller_specs => false,
    :request_specs => false
  g.fixture_replacement :factory_girl, :dir => "spec/factories"
end
```
+ now generating models/controllers will make rspec stuff
+ still need to make `spec/features` on our own - given access to Capybara

### Testing Models with RSpec
+ testing methods, validations, associations, and error messages
+ this is unit testing
+ `rails generate rspec:model Cat` if we don't have a `cat_spec` apready
+ model specs are wrapped in `describe` blocks
+ `it "does something" do...` and `expect(thing).to be(true)`
+ we can use the `valid?` method: `expect(model).to be_valid`
+ `shoulda-matchers`
```ruby
describe BasketballTeam do
  it { should validate_presence_of(:name) }
  it { should validate_uniqueness_of(:name) }
  it { should ensure_inclusion_of(:name).in_array(["Cavaliers", "Suns", "Mavericks"])} #etc..
  describe "associations" do
    # "it" refers to the BasketballTeam class here
    # because we have not specified a subject
    it { should have_many(:basketball_players)}
    it { should have_one(:owner)}
  end
end
```
+ run valid? then look at errors object to ensure correct error messages
+ can test scopes by looking at `scope.where_values_hash` and also looking at results
+ and ensuring good stuff present and bad stuff absent

### Better Fixtures with FactoryGirl and Faker
+ factories are good because instantiating models isn't DRY
+ with a factory: `FactoryGirl.build(:cat)`, pass options hash for non default vals
+ `build` makes instance, `create` builds and saves to test DB
```ruby
# my_app/spec/factories/cats.rb
FactoryGirl.define do
  factory :cat do # The name matters. :cat factory returns a Cat object.
    name 'Fluffy'
    color 'Dark Brown'
    email 'meow@meow.com'
    owner_id 1
    active true
    temperament 'mild'
  end
end
```
+ `faker` allows us to easily generate test data
+ if we want to say `build(:cat)` instead of `FactoryGirl.build(:cat)` we just:
```
# rails_helper.rb
RSpec.configure do |config|
  config.include FactoryGirl::Syntax::Methods
end
```
+ when defining a factory method arg can be a literal `name "jeff"` or  a block
+ `Faker::Name.name`
```ruby
factory :post do
  association :author, factory: :user, last_name: "Writely"
end
```
+ if the association is the name of a factory you can just say `author`
+ `sequence` helps gen models with unique vals because you get an iterator var
+ `build_list(:cat, 25)` makes 25 cats, can also create

### Testing With Capybara
+ BDD - behavior driven dev, testing what a user would actually do
+ unit tests pieces in isolation - this is integration: is it all working together
+ `gem 'capybara'`
+ specs must go in `specs/features/`
+ use `feature` instead of `describe`, `scenario` instead of `it`
+ `visit new_user_url`, can use url helpers
+ `click_link('link text')`
+  RSpec runs each test in a transaction and rolls back at end, if using
  `selenium` by setting `js: true`, it doesn't use transactions, so use `database-cleaner`
+ `gem 'launchy'` and `save_and_open_page`

### Additional Notes

* Drivers
    * Defaults to Rack::Test - this interacts with Rack interfaces directly
    * This can make requests to fake remote servers (eg sandbox)
    * These are middlewares
    * No server - app just gets requests and sends back HTML response
* Gotchas
    * Vanilla capybara isnâ€™t compatible with js - capybara webkit driver is (dom manipulation). Uses headless browser - Phantom.js (no GUI).
* Semantics
    * Rspec is a testing framework, Capybara is for acceptance tests - high level tests that simulate the actions of a real user
    * Capybara is an interface for interacting with websites from ruby

Notes from yesterday:
* Preload - two queries
* Eagerload - left outer join
* Includes - preload unless there is a reason (ie where clause) to eagerload
* Joins - inner join with duplicates possible

* Checkboxes
  * inverse_of
  * signal to used cached data, not invoke a new query

```ruby
class Dungeon < ActiveRecord::Base
  has_many :dragons, :inverse_of=>:dungeon
end

class Dragon < ActiveRecord::Base
  belongs_to :dungeon, :inverse_of=>:dragons
end

irb> p = Dungeon.new
=> #<Dungeon id: nil, name: nil, ...>
irb> t = p.dragons.build
=> #<Task id: nil, dragon_id: nil, ...>
irb> t.dungeon
=> #<Dungeon id: nil, name: nil, ...>
```
  * add [] to params in controller
  * add [] to name in views
  * add empty field in views
